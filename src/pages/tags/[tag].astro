---
import { logError } from '@utils/logHelpers';
import type { Tag } from 'src/schemas/TagSchema';
import { t } from 'src/utils/i18n';
import ProfileLink from '../../components/svelte/app/ProfileLink.svelte';
import Page from '../../layouts/Page.astro';
import {
  getTagDisplayInfo,
  resolveTagSynonym,
} from '../../schemas/TagSynonyms';

const { tag } = Astro.params;

if (!tag) {
  logError('Tag page accessed without tag');
  return Astro.redirect('/404');
}

// Resolve synonym to canonical tag
const canonicalTag = resolveTagSynonym(tag);
const tagInfo = getTagDisplayInfo(canonicalTag);

// If tag is a synonym (not canonical), redirect to canonical with 301
if (canonicalTag !== tag.toLowerCase()) {
  return Astro.redirect(`/tags/${encodeURIComponent(canonicalTag)}`, 301);
}

const origin = new URL(Astro.request.url).origin;

// Fetch site data from the api
const tagResponse = await fetch(`${origin}/api/tags/${canonicalTag}.json`);

// Handle 404 based on whether this is a featured tag
if (tagResponse.status === 404) {
  logError(`Tag not found: ${canonicalTag}`);

  // If this is a featured tag (has synonyms in TAG_SYNONYMS), show the page anyway
  // Otherwise redirect to 404
  if (!tagInfo) {
    return Astro.redirect('/404');
  }
  // For featured tags, continue to render the page with no entries
}

const tagData =
  tagResponse.status === 404
    ? {
        entries: [],
        displayName: tagInfo?.displayName || tag,
        description: tagInfo?.description,
        synonymCount: tagInfo?.synonyms.length || 0,
      }
    : await tagResponse.json();

const entries = tagData.entries as Tag[];

// SEO metadata
const displayName = tagData.displayName || tag;
const title = `#${displayName}`;
const description =
  tagData.description || t('seo:tag.fallback', { tag: displayName });

// Cache headers - tag pages can be cached aggressively
Astro.response.headers.set(
  'Cache-Control',
  'public, max-age=300, s-maxage=600, stale-while-revalidate=1800',
);
Astro.response.headers.set('Cache-Tag', `tag-${canonicalTag},public-tags`);

// Separate threads and pages
const threads = entries.filter((e) => e.type === 'thread');
const pages = entries.filter((e) => e.type === 'page');

function parseUrl(tag: Tag) {
  if (tag.type === 'page') {
    return `/sites/${tag.key}`;
  }
  return `/threads/${tag.key}`;
}
---

<Page {title} {description}>
  <div class="content-columns">
    <article class="column-l">
      <header style="margin-bottom: calc(2 * var(--cn-grid))">
        <h1>
          {tagInfo?.icon && <cn-icon noun={tagInfo.icon} />}
          {displayName}
        </h1>

        <!-- If we are on popular tag, we get a host of extra description -->
        {tagInfo?.description && (
          <p>{tagInfo.description}</p>
        )}


        {tagInfo?.synonyms && tagInfo.synonyms.length > 0 && (
          <p class="text-low">
            {t('tag:synonymsInfo', { count: tagInfo.synonyms.length })}:
          </p>
          <div class="flex">
            {tagInfo.synonyms.map((syn) => (
              <span class="cn-chip">
                #{syn}
              </span>
            ))}
          </div>
        )}
      </header>

      {threads.length > 0 && (
        <section style="margin-bottom: calc(3 * var(--cn-grid))">
          <h2 class="text-title">
            <cn-icon name="discussion" small />
            {t('tag:discussions')} ({threads.length})
          </h2>
          <ul>
            {threads.map((entry) => (
              <li class="flex items-center">
                <span style="flex: 1">
                  <a href={parseUrl(entry)}>{entry.title}</a>
                </span>
                <ProfileLink uid={entry.author} client:only="svelte"/>
              </li>
            ))}
          </ul>
        </section>
      )}

      {pages.length > 0 && (
        <section>
          <h2 class="text-title">
            <cn-icon noun="card" small />
            {t('tag:pages')} ({pages.length})
          </h2>
          <ul>
            {pages.map((entry) => (
              <li class="flex items-center">
                <span style="flex: 1">
                  <a href={parseUrl(entry)}>{entry.title}</a>
                </span>
                <ProfileLink uid={entry.author} client:only="svelte"/>
              </li>
            ))}
          </ul>
        </section>
      )}

      {entries.length === 0 && (
        <p class="text-caption">{t('tag:noEntries')}</p>
      )}
    </article>
  </div>
</Page>
